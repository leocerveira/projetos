library(gtools)
install.packages("gtools")
library(gtools)
# Gera todas as combinações possíveis de jogos (10 jogos)
jogos <- t(combn(1:5, 2))
n_jogos <- nrow(jogos)
n_times <- 5
n_rodadas <- 10
set.seed(123)
best_score <- Inf
best_tabela <- NULL
best_rodadas_time <- NULL
tentativas <- 20000
for (t in 1:tentativas) {
ordem <- sample(1:n_jogos, n_jogos)
tabela <- jogos[ordem,]
# Rodadas em que cada time joga
rodadas_time <- lapply(1:n_times, function(tt) which(tabela[,1] == tt | tabela[,2] == tt))
# Checa restrição: só pode intervalo 2 ou 3 (descansos de 1 ou 2 rodadas entre jogos)
valido <- TRUE
for (tt in 1:n_times) {
ints <- diff(rodadas_time[[tt]])
if (length(ints) > 0 && any(!(ints %in% c(2,3)))) {
valido <- FALSE
break
}
}
if (!valido) next
# Critério A: soma dos descansos entre jogos (intervalos)
sumA <- sapply(rodadas_time, function(x) sum(diff(x)))
# Critério B: soma dos descansos incluindo antes do 1º jogo
sumB <- sapply(rodadas_time, function(x) sum(c(x[1]-1, diff(x))))
# Critério C: soma dos descansos incluindo após o último jogo
sumC <- sapply(rodadas_time, function(x) sum(c(diff(x), n_rodadas - x[length(x)])))
# Variâncias
varA <- var(sumA)
varB <- var(sumB)
varC <- var(sumC)
score <- varA + varB + varC
if (score < best_score) {
best_score <- score
best_tabela <- tabela
best_rodadas_time <- rodadas_time
best_somas <- list(A=sumA, B=sumB, C=sumC)
best_vars <- c(A=varA, B=varB, C=varC)
}
}
if (!is.null(best_tabela)) {
cat("\n--- MELHOR CRONOGRAMA ENCONTRADO ---\n")
for (i in 1:n_rodadas) cat(sprintf("Rodada %d: T%d x T%d\n", i, best_tabela[i,1], best_tabela[i,2]))
cat("\nRodadas em que cada time joga:\n")
for (tt in 1:n_times) cat(sprintf("T%d: %s\n", tt, paste(best_rodadas_time[[tt]], collapse=", ")))
cat("\nSomas dos descansos:\n")
print(best_somas)
cat("\nVariâncias:\n")
print(best_vars)
cat(sprintf("\nScore total (menor é melhor): %.4f\n", best_score))
} else {
cat("Nenhum cronograma válido encontrado.\n")
}
View(best_rodadas_time)
gc()
library(gtools)
# Parâmetros do torneio
n_times <- 5
n_jogos <- choose(n_times, 2)   # 10 jogos
n_rodadas <- n_jogos
# Gera todos os jogos possíveis
jogos <- t(combn(1:n_times, 2))
set.seed(42)    # Reprodutibilidade
n_tentativas <- 110000
best_score <- Inf
best_tabela <- NULL
best_rodadas_time <- NULL
best_somas <- NULL
best_vars <- NULL
for (t in 1:n_tentativas) {
ordem <- sample(1:n_jogos, n_jogos)
tabela <- jogos[ordem, ]
# Rodadas em que cada time joga
rodadas_time <- lapply(1:n_times, function(tt) which(tabela[,1]==tt | tabela[,2]==tt))
# Checa restrição: só pode intervalo 2 ou 3 (descansos de 1 ou 2 rodadas entre jogos)
valido <- TRUE
for (tt in 1:n_times) {
ints <- diff(rodadas_time[[tt]])
# Debug: descomente para inspecionar
# cat(sprintf("Time %d: rodadas %s | intervalos %s\n", tt, paste(rodadas_time[[tt]], collapse=", "), paste(ints, collapse=", ")))
if (length(ints) > 0 && any(!(ints %in% c(2,3)))) {
valido <- FALSE
break
}
}
if (!valido) next
# Critério A: soma dos descansos entre jogos (intervalos)
sumA <- sapply(rodadas_time, function(x) sum(diff(x)))
# Critério B: soma dos descansos incluindo antes do 1º jogo
sumB <- sapply(rodadas_time, function(x) sum(c(x[1]-1, diff(x))))
# Critério C: soma dos descansos incluindo após o último jogo
sumC <- sapply(rodadas_time, function(x) sum(c(diff(x), n_rodadas - x[length(x)])))
# Variâncias
varA <- var(sumA)
varB <- var(sumB)
varC <- var(sumC)
score <- varA + varB + varC
if (score < best_score) {
best_score <- score
best_tabela <- tabela
best_rodadas_time <- rodadas_time
best_somas <- list(A=sumA, B=sumB, C=sumC)
best_vars <- c(A=varA, B=varB, C=varC)
}
}
# Exibir o melhor cronograma
if (!is.null(best_tabela)) {
cat("\n--- MELHOR CRONOGRAMA ENCONTRADO ---\n")
for (i in 1:n_rodadas) cat(sprintf("Rodada %2d: T%d x T%d\n", i, best_tabela[i,1], best_tabela[i,2]))
cat("\nRodadas em que cada time joga:\n")
for (tt in 1:n_times) cat(sprintf("T%d: %s\n", tt, paste(best_rodadas_time[[tt]], collapse=", ")))
cat("\nSomas dos descansos (Critérios A, B, C):\n")
print(best_somas)
cat("\nVariâncias das somas dos descansos (A, B, C):\n")
print(best_vars)
cat(sprintf("\nScore total (menor é melhor): %.4f\n", best_score))
} else {
cat("Nenhum cronograma válido encontrado.\n")
}
# Cronograma fixo
tabela <- matrix(c(
1,2,
3,4,
1,5,
2,3,
4,5,
1,3,
2,4,
3,5,
4,1,
5,2
), ncol=2, byrow=TRUE)
# Função para checar 2/2 mandos
check_2_2 <- function(mandos) {
count <- matrix(0, nrow=5, ncol=2) # col1: mandante, col2: visitante
for (i in 1:nrow(mandos)) {
count[mandos[i,1],1] <- count[mandos[i,1],1] + 1
count[mandos[i,2],2] <- count[mandos[i,2],2] + 1
}
all(count == 2)
}
# Gerar todas as permutações possíveis de mando (2^10 = 1024 combinações)
encontrado <- FALSE
for(i in 0:(2^10-1)) {
mandos <- tabela
bits <- as.integer(intToBits(i))[1:10]
for(j in 1:10) {
if(bits[j]==1) mandos[j,] <- rev(mandos[j,])
}
# Conta para cada time mandante/visitante
count <- matrix(0, nrow=5, ncol=2)
for (k in 1:10) {
count[mandos[k,1],1] <- count[mandos[k,1],1] + 1
count[mandos[k,2],2] <- count[mandos[k,2],2] + 1
}
if (all(count == 2)) {
encontrado <- TRUE
cat("Cronograma 2/2 encontrado:\n")
print(mandos)
print("Mandos por time (linha= time 1 a 5, col1= mandante, col2= visitante):")
print(count)
break
}
}
if (!encontrado) cat("Não existe cronograma 2/2 para essa ordem.\n")
for(i in 0:(2^10-1)) {
mandos <- tabela
bits <- as.integer(intToBits(i))[1:10]
for(j in 1:10) {
if(bits[j]==1) mandos[j,] <- rev(mandos[j,])
}
# Conta para cada time mandante/visitante
count <- matrix(0, nrow=5, ncol=2)
for (k in 1:10) {
count[mandos[k,1],1] <- count[mandos[k,1],1] + 1
count[mandos[k,2],2] <- count[mandos[k,2],2] + 1
}
if (all(count == 2)) {
encontrado <- TRUE
cat("Cronograma 2/2 encontrado:\n")
print(mandos)
print("Mandos por time (linha= time 1 a 5, col1= mandante, col2= visitante):")
print(count)
break
}
}
library("PNADcIBGE")
dados <- get_pnadc(year = 2023, interview = 4)
dados <- get_pnadc(year = 2023, quarter = 4)
gc()
dados <- get_pnadc(year = 2023, quarter = 4)
View(dados)
dados <- get_pnadc(year = 2023, topic = 4)
gc()
gc()
dados <- get_pnadc(year = 2023, topic = 4)
dados <- get_pnadc(year = 2023, topic = 4, selected = TRUE)
setwd("~/DocumentosR/Lab")
dados <- get_pnadc(year = 2023, topic = 4, selected = TRUE)
library("PNADcIBGE")
data <- get_pnadc(year = 2023, topic = 4)
data <- get_pnadc(year = 2023, topic = 4, selected = TRUE)
data <- get_pnadc(year = 2023, topic = 4)
gc()
library("PNADcIBGE")
data <- get_pnadc(year = 2023, topic = 4, design = FALSE)
View(data)
gc()
data2 <- get_pnadc(year = 2023, topic = 4, design = TRUE)
gc()
View(data)
data2 <- get_pnadc(year = 2023, topic = 4, design = TRUE)
View(data2)
